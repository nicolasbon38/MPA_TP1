---
title: "Rapport_TP2"
author: "BON, BARON, FOUSSE"
date: "10/17/2020"
output:
  html_document:
    df_print: paged
---

# Question 1
Si on suppose que c=1 alors chaque tirage de yi se fait avec la fréquence $\theta_2$. On obtient alors :
$p(y\mid c = 1, \theta _1, \theta _2) = \prod_{i = 1}^{n}\theta _2^{y_i}(1-\theta _2)^{1-y_i}$


# Question 2
On suppose que c > 1. Alors les tirages $y_i$ pour $i\in \left \| 1, c-1 \right \|$ se font avec la fréquence $\theta_1$, les autres avec la fréquence $\theta_2$. D'où : 
$p(y\mid c> 1, \theta_1, \theta_2) = \prod_{i = 1}^{c - 1} \theta _1^{y_i}(1-\theta _1)^{1-y_i}\prod_{i = c}^{n} \theta _2^{y_i}(1-\theta _2)^{1-y_i}$

# Question 3
c est uniformément distribué donc $p(c=1) = \frac{1}{n}$ ou plus simplement $p(c) = \frac{1}{n}$.
Alors:
$\frac{p(c\mid y)}{p(c=1\mid y)}$ 
= 
$\frac{p(c,y)}{p(y)}\frac{p(y)}{p(c = 1, y)}$
 = 
 $\frac{p(y \mid c)p(c)}{p(y \mid c = 1)p(c=1)}$
 = 
 $\frac{\prod_{i = 1}^{c - 1} \theta _1^{y_i}(1-\theta _1)^{1-y_i}\prod_{i = c}^{n} \theta _2^{y_i}(1-\theta _2)^{1-y_i}}{\prod_{i = 1}^{n}\theta _2^{y_i}(1-\theta _2)^{1-y_i}}$
 =
 $\frac{\prod_{i = 1}^{c - 1} \theta _1^{y_i}(1-\theta _1)^{1-y_i}}{\prod_{i = 1}^{c-1}\theta _2^{y_i}(1-\theta _2)^{1-y_i}}$
 
Pour c = k, on fait k-1 multiplications. Donc $nombre\_multiplication = \sum_{k=2}^{n}k-1 = \frac{n(n-1)}{2}$

# Question 5

```{R}
#On définit une fonction qui renvoie le nombre de y et les thetas dans un échantillon y coupé en c:

compteurs_sans_coupure <- function(y){
  compteur <- 0
  #idem dans le deuxième
  for (i in 1:length(y)){
    if (y[i] == 1){
      compteur <- compteur + 1
    }
  }
  return(c(0, compteur))
}

compteurs <- function(y, c){
    compteur1 <- 0
    if (c==1){
      return(compteurs_sans_coupure(y))#on traite le cas c=1 à part
    }
  #on compte les 1 dans le premier morceau
  compteur1 = sum(y[1:c-1])
  compteur2 = sum(y[c:length(y)])
  #idem dans le deuxième
  print(c)
  return(c(compteur1, compteur2))
}


y_test <-scan("TP2_sequence_1_2020.txt")
y <- c(rbinom(200,1,0.2),rbinom(100,1,0.6))
n <- length(y)
c <- n/2

for (iteration_algo in 1:50){
  #On calcule y1(respectivement y2), le nombre de 1 avant(respectivement apres) c.
  buffer = compteurs(y, c)
  y1 = buffer[1]
  y2 = buffer[2]
  #On suppose que comme n est grand on peut calculer chaque theta comme etant le nombre de reussites(symbolisees par 1) sur le nombre d'essais.
  t1 = y1/(c-1)
  t2 = y2/(n-c+1)
  #Creation du tableau qui va contenir les probas de c sachant Theta1, Theta2 et y. On initialise p(c=1|y,t1,t2) à 1 car on le calculera une fois que l'on aura toutes les autres probas avec la formule de recurrence.
  probas = c(1)
  
  #Afin de calculer chaque proba, on s'apprete a diviser par t2 et par 1-t2, il faut donc s'assurer que t2 ne soit égal ni a 0, ni a 1. Nous nous proposons de traiter ces cas en amont.
  if(t2==0 || t2==1){
    indice=length(y)
    while(indice >=0 && y[indice]==t2){
      indice = indice - 1
    }
    if(indice == 0){
      c=1
      t1=None
    }else{
        c = indice + 1
        t1=sum(y[1:c-1])/(c-1)
    }
    break
  }
  
  #Calcul des p(c|y,t1,t2) dans probas
  for(i in 2:n){
    pi = probas[i - 1] * (t1/t2)^y[i - 1] * ((1 - t1)/(1-t2))^(1 - y[i-1])
    probas = c(probas, pi)
  }
  
  
  #probas
  p1 = 1/(sum(probas) - 1 + 1) # - 1 pour enlever l'initialisation a 1 de p1 de la somme
  probas = probas*p1
  #print(probas)
  
  #somme = sum(probas)
  #somme
  plot.default(probas)
  #on peut alors tirer un nouveau c : on découpe l'intervalle [0, sum(probas)] en n morceaux de largeur p(c = i|y) et on regarde où on tombe
  #print(probas)
  #print("k :")
  #print(sum(probas))
  

  k = runif(1, min=0, max=sum(probas)) #=1
  #print(k)
  
  somme <- 0
  i <- 0
  
  #print(k)
  #print("somme :")
  #print(somme)
  while (somme < k){
    i = i + 1
    somme = somme + probas[i]
  }
  c = i
  print(c)
  #print(probas)
}

print(t1)
print(t2)
print(c)
```

