---
title: "rapport_TP3_MPA"
author: "BON, BARON, FOUSSE"
date: "11/10/2020"
output: html_document
---

#Partie 1

## Question 1

La loi générative s'exprime sous la forme :
\[
p(y|\theta) = \prod_{i=1}^{n} p(y_i|\theta) = \prod_{i=1}^n e^{-\theta} \times \frac{\theta^{y_i}}{y_i!} = e^{-n\theta} \times \frac{\theta^{\sum_{i=1}^n y_i}}{\prod_{i=1}^n y_i!} = e^{-n\theta} \times \frac{\theta^{n\overline{y}}}{\prod_{i=1}^ny_i!}
\]

##Question 2

Pour déterminer la loi a posteriori, on utilise la formule de Bayes :

\[
p(\theta|y) \propto p(\theta)p(y|\theta) \propto \frac{1}{\theta}e^{-n\theta}\frac{\theta^{n\overline{y}}}{\prod_{i=1}^ny_i!} \propto e^{-n\theta} \theta^{n\overline{y} - 1}
\]
avec $\overline{y} la moyenne empirique des données.

On peut calculer la constante de normalisation $C$ en intégrant cette expression par rapport à $\theta$.

\[
C = \int_0^{+\infty}e^{-n\theta}\theta^{n\overline{y} - 1}d\theta
\]
En effectuant $n\overline{y}-1$ intégrations par parties, on arrive à :
\[
C = \frac{(n\overline{y} - 1)!}{n^{n\overline{y} - 1}}
\]

Ainsi, finalement on obtient :
\[
p(\theta|y) = \frac{1}{C}e^{-n\theta}\theta^{n\overline{y} - 1}
\]

On peut à présent calculer l'espérance de la loi a posteriori :

\[
\mathbb{E}(\theta|y) = \frac{1}{C}\int_0^{+\infty}\theta p(\theta|y)d\theta = \frac{1}{C}\int_0^{+\infty}e^{-n\theta}\theta^{n\overline{y}}d\theta
\]

En réutilisant le calcul de la constante, on aboutit à :

\[
\mathbb{E}(\theta|y) = \frac{1}{C}\frac{(n\overline{y})!}{n^{n\overline{y} + 1}} = \frac{n\overline{y}}{n} = \overline{y}
\]

```{r}
# library(Rmpfr)
# les_thetas = c()
# y_read = scan(file = 'TP3_mpa_2020.txt')
# y = c()
# for (i in seq(1:40)){
#   y = c(y, y_read[i])
# }
# n=length(y)
# 
# for (i in seq(1:100)){
#   #Metropolis-Hastings
#   
#   #Etape 1
#   niter = 100
#   t = 0
#   theta.t = 11
#   precision = 100
#   
#   for (k in seq(1:niter)){
#     #Etape 2
#     theta.star = rexp(1, rate= 1 / theta.t)
#     theta.star
#     #Etape 3
#     big.theta.star = mpfr(theta.star, precision)
#     
#     big.n1 = exp(-n*theta.star)*big.theta.star^(n*mean(y) - 1)
#     n2 = dexp(theta.t, rate=1/theta.star)
#     big.theta.t = mpfr(theta.t, precision)
#     big.d1 = exp(-n*theta.t) * big.theta.t^(n*mean(y) - 1)
#     d2 = dexp(theta.star, rate=1/theta.t)
#     big.r = (big.n1 * n2)/(big.d1 * d2)
#     #print(big.r)
#         #etape 4
#     if (1 < big.r){
#       p = 1
#     }
#     else{
#       p = big.r
#     }
#     tirage = runif(1)
#     if (tirage < p){
#       theta.t = theta.star
#     }
#     #etape 5 done
#   }
# les_thetas = c(les_thetas, theta.t)
# }
# 
# hist(les_thetas)
# x_graph = seq(1:20)
# C = factorial(n*mean(y) - 1)/n^(n*mean(y) - 1)
# big.x_graph = c()
# for (j in seq(1:length(x_graph))){
#   big.x_graph = c(big.x_graph, mpfr(x_graph[j]))
# }
# big.y_graph =exp(-n*big.x_graph)*(big.x_graph)^(n*mean(y) - 1) / C
# plot(x_graph, y_graph)

```



```{R}
niter = 10000
les_thetas = c()
y_read = scan(file = 'TP3_mpa_2020.txt')
y = c()
for (i in seq(1:40)){
  y = c(y, y_read[i])
}
n=length(y)

for (i in seq(1:1000)){
  #Metropolis-Hastings
  
  #Etape 1
  niter = 100
  t = 0
  theta.t = 11

  for (k in seq(1:niter)){
    #Etape 2
    theta.star = rexp(1, rate=1/theta.t)
    #Etape 3
    if ((theta.star / theta.t)^(n*mean(y) - 1) != Inf){
      r = exp(-n * (theta.star - theta.t)) * (theta.star / theta.t)^(n*mean(y) - 1) * dexp(theta.t, rate=1/theta.star) / dexp(theta.star, rate=1/theta.t)
     # print(r)
      if (is.nan(r)){
        next
      }
        #etape 4
      if (1 < r){
        p = 1
      }
      else{
        p = r
      }
    }
    else{
      p = 1
      
    }
    tirage = runif(1)
    if (tirage < p){
      theta.t = theta.star
    }
    #etape 5 done
  }
  les_thetas = c(les_thetas, theta.t)
}
#on vire les valeurs aberrantes
les_thetas_filtres = c()
for(i in seq(1:length(les_thetas))){
  if (les_thetas[i] < 14 & les_thetas[i] > 9.5){
    les_thetas_filtres = c(les_thetas_filtres, les_thetas[i])
  }
}


print(length(les_thetas) - length(les_thetas_filtres))
hist(les_thetas_filtres, breaks=50, prob=T, main=NULL, xlim=c(0, 30), ylim = c(0,1), col="red")  #histogramme normalisé à 1
x_graph = seq(from=1, to=30, by=0.1)
#C = factorial(n*mean(y) - 1)/n^(n*mean(y) - 1)
theorique_non_normalisee <- function(x){
  return(exp(n * (mean(y) * log(x) - x)) - log(x)) #forme un peu alambiquée pour ne pas heurter l'infini machine de r
}
C_normalisation = integrate(theorique_non_normalisee, lower = 0, upper=20)$value
y_graph = theorique_non_normalisee(x_graph) / C_normalisation
lines(x_graph, y_graph / max(y_graph))

```
L'histogramme correspond. Il serait probablement plus performant avec plus de données, mais cela donnerait des valeurs trop grandes pour êtres calculées par R
